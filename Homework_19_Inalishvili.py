# დაკავშირებული სიის კოდი გაარჩიე და დააკომენტარე ყოველი მნიშვნელოვანი ადგილი.

# თავდაპირველად ვქმნით ერთმაგად დაკავშირებული სიის წევრის კლასს. init მაგიური ფუნქციით
# განვსაზღვრავთ წევრის მნიშვნელობას და მომდევნო წევრის "მისამართს", რომელიც თავდაპირველად არის None.
class ListNode:
    def __init__(self, value):
        self.value = value
        self.next = None

# შემდეგ ვქმნით ერთმაგად დაკავშირებული სიის კლასს, რომელიც init ფუნქციაში იძახებს სიის წევრის
# შესაქმნელ კლასს და ქმნის სიის პირველ(head) წევრს პარამეტრის მნიშვნელობით. ასევე განსაზღვრავს
# სიის თავდაპირველ სიგრძეს (1).
class LinkedList:
    def __init__(self, value):
        self.head = ListNode(value)
        self.length = 1

# კლასში ვამატებთ append მეთოდს, რომელიც პარამეტრად იღებს დასამატებელი სიის მნიშვნელობას, while ციკლის
# გამოყენებით პოულობს სიის ბოლოს current_node დროებითი ცვლადის გამოყენებით, რათა ბოლოში ჩაამატოს ახალი წევრი.
# შემდეგ ქმნის ახალ წევრს, შემდეგი წევრის მნიშვნელობას ანიჭებს ახალ წევრს და სიის სიგრძეს ზრდის ერთით.
    def append(self, value):
        current_node = self.head

        while current_node.next is not None:
            current_node = current_node.next

        new_node = ListNode(value)
        current_node.next = new_node
        self.length += 1


# შემდეგ კლასში ვამატებთ insert მეთოდს, რომელიც უკვე არა ბოლოში, არამედ კონკრეტულ ლოკაციაზე ქმნის ახალ წევრს.
# მეთოდი მნიშვნელობასთან ერთად ინდექსსაც იღებს პარამეტრად.
    def insert(self, value, index):
        # ვიგებთ სიის ბოლო წევრის ინდექსს.
        last_index = self.length - 1
        # ვქმით ცვლადს, რომელსცაც სიის ინდექსებს შორის იტერაციისთვის გამოვიყენებთ.
        i = 0

        # ვამოწმებთ სიის თავში ხომ არ გვსურს ახალი წევრის ჩამატება, თუ კი, არსებულ "თავს" ვანიჭებთ შემდეგი წევრის მნიშვნელობას,
        # ხოლო ახლადშექმნილი წევრი ხდება სიის "თავი". ამასთან სიის სიგრძეს ვზრდით ერთით.
        if index == 0:
            old_head = self.head
            self.head = ListNode(value)
            self.head.next = old_head
            self.length += 1

        # თუ სასურველი ლოკაცია სიის ბოლო ინდექსს ემთხვევა, მაშინ ვიძახებთ  append მეთოდს, და ის შეასრულებს შესაბამის ბიჯებს.
        elif index == last_index+1:
            self.append(value)

        # ხოლო თუ ინდექსი არც სიის თავშია და არც ბოლოში, მაშინ მიმდინარე წევრის ცვლადის(current_node) წანაცვლებით და i
        # ცვლადის გამოყენებით ვეძებთ იმ პოზიციას, სადაც უნდა ჩავსვათ ახალი წევრი.
        elif 0 < index < last_index + 1:
            current_node = self.head

            # ციკლის მეშვეობით ვადგენთ ინდექსის წინა პოზიციას, რათა i-ს მივანიჭოთ შესაბამისი მნიშვნელობა
            # და მიმდინარე წევრის ცვლადიც გადავანაცვლოთ გადაცემული ინდექსის პოზიციაზე.
            while i != index-1:
                current_node = current_node.next
                i += 1

            # ბოლოს მოცემული მნიშვნელობით ვქმნით ახალ წევრს, მის მომდევნო წევრად განვსაზღვრავთ
            # მიმდინარე წევრის(current_node) მომდევნო წევრს, ხოლო შემდეგ თვითონ ახალ წევრს ვაქცევთ მიმდინარე წევრის
            # მომდევნო წევრად, რითაც ახალი ცვლადი ჯდება ზუსტად ამ ინდექსის მომდევნო და მანამდე ამ ინდექსის მქონე წევრებს შორის.
            new_node = ListNode(value)
            new_node.next = current_node.next
            current_node.next = new_node
            self.length += 1

        # მეთოდის ბოლოში ვამოწმებთ, პარამეტრად გადაცემული ინდექსი ხომ არ სცდება არსებულ დიაპაზონს და
        #  გადის სიის ფარგლებს გარეთ.
        elif index > last_index + 1 or index < 0:
            print("Index Is Out Of Range")


    # შემდეგ ვქმნით remove მეთოდს, რათა სასურველ პოზიციაზე ამოვაკლოთ წევრი სიას. ეს მეთოდი სტრუქტურით
    # იმეორებს insert მეთოდის აგებულებას, რათქმაუნდა, ლოგიკური განსხვავებების შესაბამისად.
    def remove(self, index):

        # აქაც ვქმნით სიის ბოლო ინდექსისა  i ცვლადებს შემდგომი იტერაციისთვის.
        last_index = self.length - 1
        i = 0

        # ვამოწმებთ გადაცემული ინდექსი სიის თავშია, ბოლოში, თუ მათ შორის.
        # პირველ შემთხვევაში პირველ წევრად ვაქცევთ მანამდე არსებული პურველი წევრის მომდევნო წევრს,
        # ხოლო სიის სიგრძეს ვამცირებთ ერთით.
        if index == 0:
            self.head = self.head.next
            self.length -= 1
        # თუ ბოლო წევრის ამოღება გვსურს, მაშინ, ჯერ ციკლით "მოვდივართ" ბოლოს წინა წევრამდე
        # და მის მომდევნო წევრის ცვლადს ვასუფთავებთ (ვუთითებთ None-ს), რითაც ვწყვეტთ სიის კავშირს ამ წევრთან
        # ხოლო სიის სიგრძეს ისევ ერთით ვამცირებთ.
        elif index == last_index:
            current_node = self.head

            while i < last_index - 1:
                current_node = current_node.next
                i += 1

            current_node.next = None
            self.length -= 1

        # თუკი გადაცემული ინდექსი არც სიის თავშია და არც ბოლოში, მაშინ ისევ ციკლის, დროებითი ცვლადის და i ინდექსის
        # გამოყენებით ვპოულობთ შესაბამის პოზიციას. ამ პოზიციაზე მყოფი წევრის მომდევნო წევრის ცვლადს ვანიჭებთ
        # წასაშლელი ელემენტის ცვლადს, და "ბმას" ვამყარებთ უკვე შემდეგ წევრთან, რითაც წასაშლელი წევრი ამოვარდება სიიდან.
        elif 0 < index < last_index:
            current_node = self.head
            while i != index - 1:
                current_node = current_node.next
                i += 1

            deleted_element = current_node.next
            current_node.next = deleted_element.next
            self.length -= 1
        # მეთოდის ბოლოში ისევ ვამოწმებთ, გადაცემული ინდექსი თუ ხვდება სიის ფარგლებში.
        elif index > last_index + 1 or index < 0:
            print("Index Is Out Of Range")




    # ბოლოში სიის კონსოლში გამოსატანად ვქმნით printList მეთოდს, რომელიც ჯერ პირველ წევრს
    # დაპრინტავს, შემდეგ კი while ციკლის გამოყენებით და მიმდინარე წევრის ცვლადის წანაცვლებით
    # მთელ სიას გაივლის ბოლომდე, სანამ მომდევნო წევრის ცვლადი ცარიელი არ იქნება.
    def printList(self):
        current_node = self.head
        print(f"{current_node.value} ->", end="")

        while current_node.next is not None:
            current_node = current_node.next
            print(f" {current_node.value} ->", end="")


