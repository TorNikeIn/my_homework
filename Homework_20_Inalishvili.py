# მოიძიე ბინარული ხის მონაცემთა სტრუქტურის კოდი და დააკომენტარე. (Binary Tree Data Structure in Python)


# ბინარული ხე წარმოადგენს მონაცემთა სტრუქტურას, რომელშიც მონაცემთა კვანძები(node) მიმთითებლებით არიან
# ერთმანეთთან დაკავშირებული, მის საწყის წევრს(root) მხოლოდ ორი შვილობილი კვანძი შეიძლება ჰქონდეს: მარცხენა და მარჯვენა.
# ბინარული ძებნის ხის(BST) შემთხვევაში თუ შემდეგი წევრი ნაკლებია საწყის(root) წევრზე, ის მის მარცხენა შვილ კვანძს
# შექმნის, ხოლო თუ მეტი - მარჯვენას და ასე მიყოლებით. ეს მიდგომა ამარტივებს ძებნის პროცესს და ხეს განსაზღვრულ სტრუქტურას
# ანიჭებს. განვიხილოთ მარტივი მაგალითი.ჯერ ვქმნით კვანძის(node) კლასს, რომელშიც init მეთოდით ვქმნით პირველ წევრს(root)
# და ვანიჭებთ პარამეტრად გადაცემულ მნიშვნელობას, შემდეგ კი ვქმნით მის შვილობილ მარცხენა და მარჯვენა წევრებს თავდაპირველი
# None მნიშვნელობით.
class Node:
    def __init__(self, data):
        self.data = data
        self.leftChild = None
        self.rightChild = None

    # შემდეგ ვქმნით მეთოდს, ახალი წევრების დასამატებლად, რომელიც პარამეტრად გადაცემულ მნიშვნელობას მიანიჭებს ახალ წევრს
    # და რეკურსიის გამოყენებით მოძებნის შესაბამის ადგილს ხეზე ამ კვანძის დასამატებლად.
    def insert(self, data):
        # ვამოწმებთ, შესაქმნელი წევრის მნიშვნელობა(data), თუ არის საწყისი წევრის მნიშვნელობაზე ნაკლები, რათა საჭიროების
        # შემთხვევაში მარცხენა წახნაგზე(edge) შევქმნათ ახალი წევრი
        if data < self.data:
            if self.leftChild:
                # ვამოწმებთ კიდევ ხომ არ არის მარცხენა წევრი, რომლის მნიშვნელობაც მეტია გადაცემულ პარამეტრზე, რისთვისაც
                # რეკურსიას ვიყენებთ, სადაც root წევრის ადგილს უკვე მიმდინარე node დაიკავებს, სანამ არ გავივლით მთელ ხეს
                self.leftChild.insert(data)
            else:
                # როდესაც შესაბამის პოზიციას იპოვის, insert მეთოდი იძახებს კლასს(init მეთოდით) და ქმნის ახალ წევრს.
                self.leftChild = Node(data)
                return
        # თუ გადაცემული მნიშვნელობა(data) მეტია საწყისი წევრის მნიშვნელობაზე, მაშინ მარჯვენა "განტოტვაზე" იქმნება ახალი
        # წევრი. ვიმეორებთ იგივე ნაბიჯებს, ოღონდ უკვე მეტობის ლოგიკით. კვლავ ვიყენებთ რეკურსიას და შესაბამისი ადგილის
        # პოვნის შემდეგ ვქმნით ახალ წევრს Node კლასის ინიციაციით.
        else:
            if self.rightChild:
                self.rightChild.insert(data)
            else:
                self.rightChild = Node(data)
                return

    # შემდეგ ვამატებთ ძებნის მეთოდს. აქაც მთავარი იარაღი რეკურსიაა.
    def search(self, val):
        # თუ მოსაძებნი მნიშვნელობა თავიდანვე დაემთხვა ხის სათავეს(root), გამოგვაქვს შესაბამისი მესიჯი.
        if val == self.data:
            return str(val) + " is found in the BST"
        # თუ მოსაძებნი მნიშვნელობა ნაკლებია root-ზე, ვეძებთ მარცხენა "ტოტზე".
        elif val < self.data:
            # ვამოწმებთ კიდევ არის თუ მარცხნივ განშტოება, რის შემთხვევაშიც თავიდან ვიძახებთ ძებნის მეთოდს, სანამ ყველა
            # კვანძს(node) არ შევამოწმებთ რეკურსიულად.
            if self.leftChild:
                return self.leftChild.search(val)
            else:
                # თუ ყველა მარცხენა კვანძის მარცხენა კვანძი შევამოწმეთ და ვერ ვიპოვეთ ტოლი მნიშვნელობა, ძებნა სრულდება
                # და ვაბრუნებთ შესაბამის მესიჯს. (მარჯვნივ ვერ იქნება მოსაძებნი მნიშვნელობა, რადგან ყოველ ჯერზე
                # გადაცემული პარამეტრი(val) ნაკლები იყო შესადარებელ მნიშვნელობაზე, ე.ი. მარჯვნივ ვერ იქნებოდა)
                return str(val) + " is not found in the BST"
        # თუ მოსაძებნი მნიშვნელობა მეტია საწყის წევრზე(root) ვავითარებთ იგივე პროცესს, მაგრამ უკვე მეტობის ლოგიკით.
        else:
            if self.rightChild:
                return self.rightChild.search(val)
            else:
                return str(val) + " is not found in the BST"


    # ბოლოს ვამატებთ მთლიანი ხის ამოსაბეჭდ მეთოდს, რომელშიც ჯერ ვამოწმებთ, თუ აქვს ხეს მარცხენა განშტოება, რომ მასზე
    # გამოვიძახოთ ისევ printTree მეთოდი რეკურსიულად. შემდეგ ვპრინტავთ root წევრს(რეალურად, რეკურსიის დროს ეს ხაზი
    # დაპრინტავს ბინარული ხის ყველა წევრს, რადგან თითოეულ ბიჯზე შესაბამისი child node "იქნება" root node).
    # ბოლოს კი ვამოწმებთ მარჯვენა განშტოებას და იქ არსებულ კვანძებს შორის გავირბენთ რეკურსიით.
    def printTree(self):
        if self.leftChild:
            self.leftChild.printTree()
        print(self.data)
        if self.rightChild:
            self.rightChild.printTree()

